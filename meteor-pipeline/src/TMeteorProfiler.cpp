/*
 * Copyright 2017-2020, Franck Gauthier <franck.gauthier@inrae.fr>, Nicolas Pons <nicolas.pons@inrae.fr>
 *
 * This file is part of Meteor v3.2.
 *
 * Meteor v3.2 is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Meteor v3.2 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Meteor v3.2. If not, see <http://www.gnu.org/licenses/>.
 */

#include <fstream>
#include "TReferenceIniFile.h"
#include "TMeteorProfiler.h"

using namespace std;

TMeteorProfiler::TMeteorProfiler(const string & aMeteorJobIniFileName, const string & aProjectDirectory, const string & aProfileDirectory,
		                         const TCountedReadType aCountedReadType, const vector<string> & aInputData, const bool aOkToCreateMatrix): FMeteorJobIniFile(aMeteorJobIniFileName) {

	FProjectDirectory = aProjectDirectory;
	FProfileDirectory = aProfileDirectory;
	FCountedReadType = aCountedReadType;
	FRunSampleCount = 0;
	FSampleCount = 0;
	FIsHostRemoved = true;
	FOkToCreateMatrix = aOkToCreateMatrix;

	FMeteorJobIniFile.GetExcludedReferenceNameList(FExcludedReferenceNameList);
	FMeteorJobIniFile.GetMainReferenceProperties(FMappingMainReferenceProperties);

	/// aInputData contained the list of counting results filenames (one per sample, e.g. /path/to/mapping/sample1/.../census.dat) in a vector (FSampleProfileFileNames).

	size_t pos = aInputData[0].rfind(".txt");
	// string ends with .txt => load the list of input files from this text file
	//if (pos != string::npos) {
	if (pos == aInputData[0].size() - 4) {

		cout << "loading input files list from "<< aInputData[0] << endl;
		// Open the File
		ifstream in(aInputData[0].c_str());

		// Check if object is valid
		if(!in)	{
			cerr << "Cannot open the File : "<<aInputData[0]<<endl; exit(1);
		}
		string line;
		while (std::getline(in, line)) { // ending '\n' is removed
			// erase potential ending '\r' (dos formated file)
			string::reverse_iterator rit = line.rbegin();
			if (rit != line.rend() && *rit == '\r') line = line.erase(line.size()-1);
			if(line.empty()) continue; // skip emty line

			FSampleProfileFileNames.push_back(line);
		}
		in.close();
	}
	// vector copy, not reference
	else FSampleProfileFileNames = aInputData;

	size_t aFilesNb = FSampleProfileFileNames.size();
	FCountingStatisticsArray.resize(aFilesNb);

	FSampleProfileIniFileNames.resize(aFilesNb);
	FSampleNames.resize(aFilesNb);

	for (size_t i = 0; i < aFilesNb; i++){
		string & aCountingResultFileName = FSampleProfileFileNames.at(i);

		if ( access(aCountingResultFileName.c_str(), F_OK) != 0) {
			cerr << "Error, file not found "<< aCountingResultFileName << endl;
			exit(1);
		}
		// path to corresponding gene_profile.ini
		FSampleProfileIniFileNames[i] = ExtractFileDir(aCountingResultFileName)+C_EXT_INIFILE;

		if ( access(FSampleProfileIniFileNames[i].c_str(), F_OK) != 0) {
			cerr << "Error, file not found "<< FSampleProfileIniFileNames[i] << endl;
			exit(1);
		}

		TProfileIniFile aSampleProfileIniFile(FSampleProfileIniFileNames[i], true);
		if (aSampleProfileIniFile.GetSequencedHostReadCount() < 0) FIsHostRemoved = false;

		FSampleNames[i] = aSampleProfileIniFile.GetSampleName();

		LoadCountingInfo(FSampleProfileIniFileNames[i]);
	}
	cout << "SampleCount: " << FSampleCount << endl;
	cout << "RunSampleCount: " << FRunSampleCount << endl;
}

// ------------------------------------------------------------------------------

TMeteorProfiler::~TMeteorProfiler() {
}

// ------------------------------------------------------------------------------
// load lite_annaotation to get each fragment (gene) size
// aProfileName is the prefix basename of the files generated by the profiling process.
//void TMeteorProfiler::CreateProfile(const string & aProfileName, const string & aProjectName, const TCountedReadType & aCountedReadType, const TMeteorProfileNormalizationType & aProfileNormalizationType)
void TMeteorProfiler::CreateProfile(const string & aProfileName)
{

	cout << "\n######### profiling job started\n" << endl;

	// Prepare repository profile directory
	if ( access(FProfileDirectory.c_str(), F_OK) != 0 ) {// test if file or directory exists
		if ( my_mkdir(FProfileDirectory.c_str()) != 0) {
			cerr << "Error, could not create "<< FProfileDirectory << endl;
			exit(1);
		}
	}

	/// get reference informations (i.e. fragments count)

	string aReferenceIniFileName = FMeteorJobIniFile.GetReferenceDir() + C_PATH_SEP + FMappingMainReferenceProperties.ReferenceName + C_PATH_SEP + FMappingMainReferenceProperties.ReferenceName + C_DEFAULT_REFERENCE_INIFILE_NAME_EXTENSION;
	TReferenceIniFile aReferenceIniFile(aReferenceIniFileName);

	if (aReferenceIniFile.GetHasLiteInfo()){
		FReferenceAnnotationDatabase.OpenLiteReferenceAnnotationTable(
						  ExtractFileDir(aReferenceIniFileName) + C_PATH_SEP + aReferenceIniFile.GetReferenceDatabaseDirectory()
						  + C_PATH_SEP + aReferenceIniFile.GetReferenceName() + '_' + C_REFERENCE_LITE_ANNOTATION_TABLE_NAME);
	}
	else {
		cerr << "Error in TMeteorProfiler::CreateProfile: " << aReferenceIniFileName << " shows that lite_info is missing" << endl;
		exit(1);
	}
	int aTotalFragmentCount = FReferenceAnnotationDatabase.GetLiteReferenceAnnotationTable().GetFragmentCount();


/////// 1- build gene profile if needed
	if (FOkToCreateMatrix) {
		string aProfileOutpout = FProfileDirectory + C_PATH_SEP + aProfileName+".tsv";

		// Open output file in write mode (ascii text)
		ofstream aOutputFile(aProfileOutpout.c_str(), ios::out);
		if (!aOutputFile){
			cerr << "Error, could not open file in write mode: " << aProfileOutpout;
			exit(1);
		}
		// write output file header
		aOutputFile << "#"+FD_FRAGMENT_ID;
		for(int i = 0; i < FSampleCount; i++) aOutputFile << '\t' << FSampleNames[i];
		aOutputFile << endl;

		aOutputFile.precision(15); // 15 significant digits.

		// initialize aProfileTable: object managing the merge columns of the desired counting type in a 2D array.
		TProfileTable aProfileTable(FSampleProfileFileNames, FCountedReadType);

		/// MergeColumns read the file(s) and returns the number of lines read:
		//    exactly FMaxRowsNumber, except for the last block (0 < n <= FMaxRowsNumber).
		//    and 0 when the end of the file(s) is reached.
		int aReadLinesNb;
		////while ( (aReadLinesNb = aProfileTable.MergeColumns(FCountedReadType)) > 0 ) {
		while ( (aReadLinesNb = aProfileTable.MergeColumns()) > 0 ) {
			// write the content of F2Darray in outpout file
			aProfileTable.Write2DArray(aReadLinesNb, aOutputFile);
			if (aProfileTable.GetLineNumber() % 1000000 == 0) cout << aProfileTable.GetLineNumber() << " processed records." << endl;
		}
		aOutputFile.close();

		if (aTotalFragmentCount != aProfileTable.GetLineNumber()){
			cerr << "\nWARNING !!! "<< endl;
			cerr << "    " << aProfileTable.GetLineNumber() << " records written in " << aProfileOutpout << endl;
			cerr << "    " << aTotalFragmentCount << " fragments (genes) found in reference catalog ..." << endl;
			exit(1);
		}
		cout << aTotalFragmentCount << " processed records." << endl;
		cout << "\nMerged profiled data are saved here: " << aProfileOutpout << endl;
	}
	else {
		cout << "\nINFO: Merging of profiled data not requested, skipped." << endl;
	}

///////////////////////////////////////

    // 2- create profile ini-file. TProfileIniFile constructor open in write mode by default.

    TProfileIniFile aProfileIniFile(FProfileDirectory + C_PATH_SEP + aProfileName + C_DEFAULT_PROFILE_INIFILE_NAME_EXTENSION);
    string aProjectName = BaseName(FProjectDirectory); //// TODO find a better way to get project name.

    aProfileIniFile.SetMeteorConfigPath(FMeteorJobIniFile.getIniFilename());
	aProfileIniFile.SetProfileName(aProfileName);
	aProfileIniFile.SetProfileFileName(aProfileName);
	aProfileIniFile.SetProfileDate(str_now());
	aProfileIniFile.SetProjectName(aProjectName);
	aProfileIniFile.SetCountedReadType(FCountedReadType);
	//aProfileIniFile.SetNormalizationType(aProfileNormalizationType);
	aProfileIniFile.SetNormalizationType(mpnNone);
	aProfileIniFile.SetReferenceName(FMappingMainReferenceProperties.ReferenceName);
	aProfileIniFile.SetMappedReadLength(FMappingMainReferenceProperties.MappedReadLength);
	aProfileIniFile.SetMappedReadLengthType(FMappingMainReferenceProperties.MappedReadLengthType);
	aProfileIniFile.SetMappingMismatchesCount(FMappingMainReferenceProperties.MappingMismatches);
	aProfileIniFile.SetIsMappingMismatchesPercentage(FMappingMainReferenceProperties.IsMappingMismatchesPercentage);
	aProfileIniFile.SetMappingMatchesCount(FMappingMainReferenceProperties.MappingMatches);
	aProfileIniFile.SetIsBestAlignment(FMappingMainReferenceProperties.IsBestAlignment);
	aProfileIniFile.SetMappingToolName(FMeteorJobIniFile.GetMappingProgram());
	aProfileIniFile.SetMappingCmdLine(FMappingMainReferenceProperties.MapperCmd);

	/// get read cleaning methods and parameters from the first sample metadata (sample gene_profile.ini)
	TProfileIniFile aSampleProfileIniFile(FSampleProfileIniFileNames.front(), true); // true => read only
	aProfileIniFile.SetReadCleaningMethod(aSampleProfileIniFile.GetReadCleaningMethod());
	aProfileIniFile.SetReadCleaningParameters(aSampleProfileIniFile.GetReadCleaningParameters());
	//FreeAndNil(aSampleProfileIniFile);

	aProfileIniFile.SetExcludedReferenceNameList(FCurrentExcludedReferenceNameList);

	// concatenate mapped samples metatdata ([profiled_sample_N] sections of sample gene_profile.ini files)

	map<string,string> aSectionStrings;

	// iterate on FSampleProfileIniFileNames (one gene_profile.ini per sample)
	for (size_t i = 0; i < FSampleProfileIniFileNames.size(); i++)
	{
		//aSectionStrings.Clear;
		TProfileIniFile aSampleProfileIniFile(FSampleProfileIniFileNames.at(i), true);

		// iterate on each library
		for (int iLibrary = 0; iLibrary < aSampleProfileIniFile.GetProfiledSampleCount(); iLibrary++)
		{
			//aSampleProfileIniFile.GetProfiledSample(iLibrary, aSectionStrings);
			bool aSectionFound = aSampleProfileIniFile.GetProfiledSample(iLibrary, aSectionStrings);
			if (!aSectionFound){
				cerr << "Error in " << aSampleProfileIniFile.getIniFilename() << ": section " << C_PREFIX_PROFILED_SAMPLE_SECTION + "_" + numberToString(iLibrary) << "not found." << endl;
				exit(1);
			}
			aProfileIniFile.AddProfiledSample(aSectionStrings);
		}
	}

    ExportCountingStatistics(FProfileDirectory + C_PATH_SEP + aProfileName + C_DEFAULT_COUNTING_REPORT_FILENAME_EXTENSION);

    ExportExtendedCountingStatistics(FProfileDirectory + C_PATH_SEP + aProfileName + C_DEFAULT_EXTENDED_COUNTING_REPORT_FILENAME_EXTENSION);

    cout << "\n######### Job finished" << endl;
}

// ------------------------------------------------------------------------------

bool TMeteorProfiler::CheckProfileIniFile(const TProfileIniFile & aProfileIniFile)
{
	// get excluded reference names from the _gene_profile.ini
	aProfileIniFile.GetExcludedReferenceNameList(FCurrentExcludedReferenceNameList);

	// we got FExcludedReferenceNameList and FMappingMainReferenceProperties from FMeteorJobIniFile (see constuctor)
	if (
		FExcludedReferenceNameList == FCurrentExcludedReferenceNameList && // vector comparison
		FMappingMainReferenceProperties.ReferenceName == aProfileIniFile.GetReferenceName() &&
		FMappingMainReferenceProperties.MappingMatches == aProfileIniFile.GetMappingMatchesCount() &&
		FMappingMainReferenceProperties.MappingMismatches == aProfileIniFile.GetMappingMismatchesCount() &&
		FMappingMainReferenceProperties.MappedReadLength == aProfileIniFile.GetMappedReadLength() &&
		FMappingMainReferenceProperties.IsBestAlignment == aProfileIniFile.GetIsBestAlignment() &&
		FMappingMainReferenceProperties.IsMappingMismatchesPercentage == aProfileIniFile.GetIsMappingMismatchesPercentage() &&
		FMappingMainReferenceProperties.MappedReadLengthType == aProfileIniFile.GetMappedReadLengthType() &&
		FMappingMainReferenceProperties.MapperCmd == aProfileIniFile.GetMappingCmdLine() )
	{
	  return true;
	}
	return false;
}


// ------------------------------------------------------------------------------
// This method is called for each sample (gene_profile.ini file),
// so, once all samples are evaluated, the final value of FRunSampleCount should be FsampleCount * (sum of eachSampleLibraryCount)

void TMeteorProfiler::FillExtendedCountingStatisticsArray(const TProfileIniFile & aProfileIniFile)
{
	TCountingStatistics aCountingStatistics;

	int aLibrariesCount = aProfileIniFile.GetProfiledSampleCount();

	FExtendedCountingStatisticsArray.resize(FRunSampleCount+aLibrariesCount); //// FillExtendedCountingStatisticsArray is called for each _gene_profile.ini file

	for (int iLibrary = 0; iLibrary < aLibrariesCount; iLibrary++)
	{
		int aIndex = FRunSampleCount++; //// post-incrementation

		//// FExtendedCountingStatisticsArray.resize(FRunSampleCount); //// done before the loop

		// aCountingStatisticsItem is a reference
		TCountingStatisticsItem & aCountingStatisticsItem = FExtendedCountingStatisticsArray.at(aIndex); //// AT

		aCountingStatisticsItem.ExcludedReferenceReadCountList.resize(FExcludedReferenceNameList.size());

//		if (FIsUsualSampleName)
//			aCountingStatisticsItem.SampleName = aProfileIniFile.GetUsualSampleName
//		else
//			aCountingStatisticsItem.SampleName = aProfileIniFile.GetSampleName;

		aCountingStatisticsItem.SampleName = aProfileIniFile.GetSampleName();

		aCountingStatisticsItem.ConditionName = aProfileIniFile.GetConditionName();
		aCountingStatisticsItem.ReferenceName = aProfileIniFile.GetReferenceName();
		aCountingStatisticsItem.MappingTool = aProfileIniFile.GetMappingToolName();
		aCountingStatisticsItem.Mismatches = aProfileIniFile.GetMappingMismatchesCount();
		aCountingStatisticsItem.Matches = aProfileIniFile.GetMappingMatchesCount();
		aCountingStatisticsItem.MappedReadLength = aProfileIniFile.GetMappedReadLength();

		aCountingStatisticsItem.SampleRunName = aProfileIniFile.GetProfiledSampleFullName(iLibrary);
		aCountingStatisticsItem.SequencingDate = aProfileIniFile.GetProfiledSequencingDate(iLibrary);

		aCountingStatistics = aProfileIniFile.GetCountingStatistics(iLibrary);

		// here retrieve raw_sequence_read_count for having not cleaned data
		aCountingStatisticsItem.SequencedReadCount = aCountingStatistics.RawSequencedReads;
		aCountingStatisticsItem.HostReadCount = aCountingStatistics.HostSequencedReads;
		aCountingStatisticsItem.IndexedReadCount = aCountingStatistics.IndexedReads;
		aCountingStatisticsItem.CountedReadCount = aCountingStatistics.TotalCleanCountedReads;
		aCountingStatisticsItem.UniqueCountedReadCount = aCountingStatistics.UniqueCleanCountedReads;
		aCountingStatisticsItem.RejectedReadCount = aCountingStatistics.RejectedReads;
		aCountingStatisticsItem.NotAssignedReadCount = aCountingStatistics.NotMappedReads;
		aCountingStatisticsItem.ExcludedReferenceReadCount = aCountingStatistics.RejectedReferenceReads;
		aCountingStatisticsItem.NotAssignedCleadReadCount = aCountingStatistics.NotMappedCleanReads;

		for (size_t i = 0; i < FExcludedReferenceNameList.size(); i++)
		{
			aCountingStatisticsItem.ExcludedReferenceReadCountList[i] = aProfileIniFile.GetExcludedReferenceReadCount(iLibrary, i + 1);
		}
	}
}

// ------------------------------------------------------------------------------

void TMeteorProfiler::ExportCountingStatistics(const string & aFileName)
{
	const string COMMA_SEP = ",";
	const string QUOTE_SEP = "\"";
//	TCountingStatisticsItem aCountingStatisticsItem;

	// add the column "removed_host_reads_count" if preprocessing (prior to meteor) has removed host reads
	string aHostInHeader = (FIsHostRemoved == true) ? QUOTE_SEP+"removed_host_reads_count"+QUOTE_SEP + COMMA_SEP : "";

	string aHeader = QUOTE_SEP+"sample"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"condition"+QUOTE_SEP + COMMA_SEP +
			QUOTE_SEP+"reference"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"mapping_tool"+QUOTE_SEP + COMMA_SEP +
			QUOTE_SEP+"mismatches"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"mapped_read_length"+QUOTE_SEP + COMMA_SEP +
			aHostInHeader +
			QUOTE_SEP+"read_count"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"HQ_read_count"+QUOTE_SEP + COMMA_SEP +
			QUOTE_SEP+"HQ_clean_read_count"+QUOTE_SEP + COMMA_SEP;
	//// HOST

	for (size_t i = 0 ; i < FExcludedReferenceNameList.size(); i++)
		aHeader += QUOTE_SEP+FExcludedReferenceNameList[i]+"_excluded_read_count"+QUOTE_SEP + COMMA_SEP;

	aHeader += QUOTE_SEP+"mapped_read_count"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"%mapped_read_count"+QUOTE_SEP + COMMA_SEP +
			QUOTE_SEP+"unique_mapped_read_count"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"%unique_mapped_read_count"+QUOTE_SEP;

	ofstream aFile(aFileName.c_str(), ios::out);
	if (!aFile) { cerr << "Error, opening "<<aFileName<<" failed."<< endl; exit(1); }

	// write the header
	aFile<<aHeader<<endl;

	for (size_t i = 0; i<FCountingStatisticsArray.size(); i++) {

		TCountingStatisticsItem & aItem = FCountingStatisticsArray[i];

		int aSumReadCount = aItem.NotAssignedCleadReadCount + aItem.CountedReadCount;

		// add the "removed_host_reads_count" column value if preprocessing (prior to meteor) has removed host reads
		string aHostStats = (FIsHostRemoved == true) ? numberToString(aItem.HostReadCount) + COMMA_SEP : "";

		string aStatLine = QUOTE_SEP+aItem.SampleName+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+aItem.ConditionName+QUOTE_SEP +
				COMMA_SEP + QUOTE_SEP+aItem.ReferenceName+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+aItem.MappingTool+QUOTE_SEP + COMMA_SEP +
				numberToString(aItem.Mismatches) + COMMA_SEP + numberToString(aItem.MappedReadLength) + COMMA_SEP +
				aHostStats +
				numberToString(aItem.SequencedReadCount) + COMMA_SEP + numberToString(aSumReadCount + aItem.ExcludedReferenceReadCount) + COMMA_SEP +
				numberToString(aSumReadCount) + COMMA_SEP;
		//// HOST

		for (size_t i = 0; i<FExcludedReferenceNameList.size(); i++)
			aStatLine += numberToString(aItem.ExcludedReferenceReadCountList[i]) + COMMA_SEP;

		if (aSumReadCount > 0){
			aStatLine += numberToString(aItem.CountedReadCount) + COMMA_SEP + numberToString(100 * (aItem.CountedReadCount / (double)aSumReadCount), 15) + COMMA_SEP + numberToString(aItem.UniqueCountedReadCount) + COMMA_SEP +
				numberToString(100 * (aItem.UniqueCountedReadCount / (double)aSumReadCount), 15);
		}
		else
			aStatLine += numberToString(aItem.CountedReadCount) + COMMA_SEP + '0' + COMMA_SEP + numberToString(aItem.UniqueCountedReadCount) + COMMA_SEP + '0';

		aFile << aStatLine << endl;

	}
	aFile.close();

	cout << "\nCounting report is saved here: " << aFileName << endl;
}

// ------------------------------------------------------------------------------

void TMeteorProfiler::ExportExtendedCountingStatistics(const string & aFileName)
{
	const string COMMA_SEP = ",";
	const string QUOTE_SEP = "\"";
//	TCountingStatisticsItem aCountingStatisticsItem;

	// add the column "removed_host_reads_count" if preprocessing (prior to meteor) has removed host reads
	string aHostInHeader = (FIsHostRemoved == true) ? QUOTE_SEP+"removed_host_reads_count"+QUOTE_SEP + COMMA_SEP : "";

	string aHeader = QUOTE_SEP+"sample"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"condition"+QUOTE_SEP + COMMA_SEP +
			QUOTE_SEP+"run_sample"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"sequencing_date"+QUOTE_SEP + COMMA_SEP +
			QUOTE_SEP+"reference"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"mapping_tool"+QUOTE_SEP + COMMA_SEP +
			QUOTE_SEP+"mismatches"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"mapped_read_length"+QUOTE_SEP + COMMA_SEP +
			aHostInHeader +
			QUOTE_SEP+"read_count"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"HQ_read_count"+QUOTE_SEP + COMMA_SEP +
			QUOTE_SEP+"HQ_clean_read_count"+QUOTE_SEP + COMMA_SEP;
	//// HOST

	for (size_t i = 0 ; i < FExcludedReferenceNameList.size(); i++)
		aHeader += QUOTE_SEP+FExcludedReferenceNameList[i]+"_excluded_read_count"+QUOTE_SEP + COMMA_SEP;

	aHeader += QUOTE_SEP+"mapped_read_count"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"%mapped_read_count"+QUOTE_SEP + COMMA_SEP +
			QUOTE_SEP+"unique_mapped_read_count"+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+"%unique_mapped_read_count"+QUOTE_SEP;

	ofstream aFile(aFileName.c_str(), ios::out);
	if (!aFile) { cerr << "Error, opening "<<aFileName<<" failed."<< endl; exit(1); }

	// write the header
	aFile<<aHeader<<endl;

	for (size_t i = 0; i<FExtendedCountingStatisticsArray.size(); i++) {

		TCountingStatisticsItem & aItem = FExtendedCountingStatisticsArray[i];

		int aSumReadCount = aItem.NotAssignedCleadReadCount + aItem.CountedReadCount;

		// add the "removed_host_reads_count" column value if preprocessing (prior to meteor) has removed host reads
		string aHostStats = (FIsHostRemoved == true) ? numberToString(aItem.HostReadCount) + COMMA_SEP : "";

		string aStatLine = QUOTE_SEP+aItem.SampleName+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+aItem.ConditionName+QUOTE_SEP +
			COMMA_SEP + QUOTE_SEP+aItem.SampleRunName+QUOTE_SEP + COMMA_SEP + aItem.SequencingDate +
			COMMA_SEP + QUOTE_SEP+aItem.ReferenceName+QUOTE_SEP + COMMA_SEP + QUOTE_SEP+aItem.MappingTool+QUOTE_SEP + COMMA_SEP +
			numberToString(aItem.Mismatches) + COMMA_SEP + numberToString(aItem.MappedReadLength) + COMMA_SEP +
			aHostStats +
			numberToString(aItem.SequencedReadCount) + COMMA_SEP + numberToString(aSumReadCount + aItem.ExcludedReferenceReadCount) + COMMA_SEP +
			numberToString(aSumReadCount) + COMMA_SEP;
		//// HOST

		for (size_t i = 0; i<FExcludedReferenceNameList.size(); i++)
			aStatLine += numberToString(aItem.ExcludedReferenceReadCountList[i]) + COMMA_SEP;

		if (aSumReadCount > 0)
			aStatLine += numberToString(aItem.CountedReadCount) + COMMA_SEP + numberToString(100 * (aItem.CountedReadCount / (double)aSumReadCount), 15) + COMMA_SEP + numberToString(aItem.UniqueCountedReadCount) + COMMA_SEP +
				numberToString(100 * (aItem.UniqueCountedReadCount / (double)aSumReadCount), 15);
		else
			aStatLine += numberToString(aItem.CountedReadCount) + COMMA_SEP + '0' + COMMA_SEP + numberToString(aItem.UniqueCountedReadCount) + COMMA_SEP + '0';

		aFile << aStatLine << endl;
	}

	aFile.close();

	cout << "\nExtended counting report is saved here: " << aFileName << endl;
}

// ------------------------------------------------------------------------------

// this procedure is called for each gene_profile.ini (one per sample)
void TMeteorProfiler::LoadCountingInfo(const string & aProfileIniFileName)
{
	TCountingStatistics aCountingStatistics;

	TProfileIniFile aProfileIniFile(aProfileIniFileName, true); // load gene_profile.ini file, read only

	if (CheckProfileIniFile(aProfileIniFile))
	{
		FillExtendedCountingStatisticsArray(aProfileIniFile);

//      if (FIsUsualSampleName)
//        aSampleName = UsualSampleName
//      else
//        aSampleName = SampleName;
		string aSampleName = aProfileIniFile.GetSampleName();

		aCountingStatistics = aProfileIniFile.GetCountingStatistics();

		// FCountingStatisticsArray is already at the good size (see constructor)
		TCountingStatisticsItem & aCountingStatisticsItem = FCountingStatisticsArray.at(FSampleCount); //// AT

		aCountingStatisticsItem.ExcludedReferenceReadCountList.resize(FExcludedReferenceNameList.size());
		aCountingStatisticsItem.SampleName = aSampleName;
		aCountingStatisticsItem.ConditionName = aProfileIniFile.GetConditionName();
		aCountingStatisticsItem.ReferenceName = aProfileIniFile.GetReferenceName();
		aCountingStatisticsItem.MappingTool = aProfileIniFile.GetMappingToolName();
		aCountingStatisticsItem.Mismatches = aProfileIniFile.GetMappingMismatchesCount();
		aCountingStatisticsItem.Matches = aProfileIniFile.GetMappingMatchesCount();
		aCountingStatisticsItem.MappedReadLength = aProfileIniFile.GetMappedReadLength();
		// here retrieve raw_sequence_read_count for having not cleaned data
		aCountingStatisticsItem.SequencedReadCount = aCountingStatistics.RawSequencedReads;
		aCountingStatisticsItem.HostReadCount = aCountingStatistics.HostSequencedReads; //// HOST NOT USEFULL ????
		aCountingStatisticsItem.CountedReadCount = aCountingStatistics.TotalCleanCountedReads;
		aCountingStatisticsItem.UniqueCountedReadCount = aCountingStatistics.UniqueCleanCountedReads;
		aCountingStatisticsItem.RejectedReadCount = aCountingStatistics.RejectedReads;
		aCountingStatisticsItem.NotAssignedReadCount = aCountingStatistics.NotMappedReads;
		aCountingStatisticsItem.ExcludedReferenceReadCount = aCountingStatistics.RejectedReferenceReads;
		aCountingStatisticsItem.NotAssignedCleadReadCount = aCountingStatistics.NotMappedCleanReads;
		for (size_t i = 0 ; i < FExcludedReferenceNameList.size(); i++)
			aCountingStatisticsItem.ExcludedReferenceReadCountList.at(i) = aProfileIniFile.GetExcludedReferenceReadCount(i + 1); //// AT

		FSampleCount++;
	}
	else {
		cerr << "Error while checking " << aProfileIniFileName << endl;
		cerr << "data in section "+C_PROFILE_INFO_SECTION+" should match with data in "<< FMeteorJobIniFile.getIniFilename() <<endl;
		exit(1);
	}
}

// ------------------------------------------------------------------------------
